-Create a repository
-Initialize a repository
-node_module,package.json,package-lock.json
-Install express
-Create server
-Listen to port 7777
-Write a request handler for /help, /test
-Install nodemon and update scripts inside package.json
-What are dependencies
-What is the use of "-g" while npm install
-Difference between "^" and "~"
-Initialize  git
-.gitignore
-Create a remote repo on github
-Push all code to remote origin
-Play with routes and route extensions ex. /hello /help
-order of the routes matters lot
-Install postman make workspace -collection make API calls
-Write a logic to handle GET, POST, PATCH, DELETE Api calls and test them on POSTMAN
-Exploring route handlers and use +,*,?,() in the routes
-Use of regex in the routes /a/ , /.*fly$/
-Read the query params in the routes
-Reading the dynamic routes
-Multiple route handler-play with the code
-next()
-next() functions and errors along with res.send()
-app.use("/",rH1,[rH2],rH3)
-What is middleware
-How express JS handles req behind the seen
-Difference between app.use() and app.all()
-Write a dummy auth middleware for admin
-Write a dummy auth middleware for all users routes, except /user/login 

-create a free cluster on mongodb official website (mongo atlas)
-Install mongoose library
-Connect your application to the database "<URL>/devTinder"
-Call the connectDB function and connect to database before starting to the application on 7777
-Create a userSchema and userModel
-Push some documents using API calls from postman
-error handling using try catch

-JS object vs JSON
-Add the express.json middleware to your app
-Make your sign api dynamic to receive the data from end user
-User.findOne({}) with duplicate email ids, which object returns
-API Get user by email
-API -feed API -Get /feed -get all users from database
-API -get user by id
-Create a delete user API
-Difference between PATCH and PUT
-API update a user
-Explore the mongoose documentation for model methods
-What are options in model. Find one and update method, explore more about it
-API -update the user with email id

-Explore schemaType options from the validation
-add require,lowercase,trim,min,minlength
-Add default
-Create a custom validate function for gender
-Improve DB schema -put all appropriate validations on each field in schema
-Add timestamps to user schema
-Add API level validation on Patch request and SignUp post api
-Data sanitizing -add API validation for each field
-Install validator
-Explore validator Library and use validator function fro gmail, password and photoURL
-NEVER TRUST req.body

-Validate data in SignUp API
-Install bcrypt package
-Create bcrypt password using bcrypt.hashand save the user is excrupted password
-Create alogin API
-Compare password throw error If gmail or password is invalid

-install cookie-parser
-just send a dummy cookie to the user
-create GET /profile API to check user is getting back cookie with tokens
-install json webtoken 
-In login API, after email and password validation, create a jwt token and send it to user in cookies
-read the cookie inside your profile API and find the logged in user
-create and userAuth middleware
-Add the userAuth middleware in profile API and send connectionResquest API
-Set the expiry of JWT token and cookies for 7 days
-Create userSchema methods for JWTtoken and passwordvalidity(passwordByUser)

-Explore tinder APIs
-Create a list all API you can think of in Dev Tinder
-Groups multiple routes into their respective router
-Read documentation for express.router
-Create route folder for managing auth,profile,request routers
-create authRouter, profileRouter, requestRouter
-Import this routes in app.js
-Create a post /logout api
-create a PATCH /profile/edit
-Create /PATCH/profile/password api=>Forgot password password api
-Make you validate in all data in every /POST /PATCH api 
